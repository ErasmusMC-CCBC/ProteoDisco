# # Author:  Job van Riet / Wesley van de Geer
# # Date: 22-07-2021
# # Function: Generate customized protein-databases using various different tool-kits.
#
#
# # Import libraries --------------------------------------------------------
#
# library(plyr)
# library(dplyr)
#
#
# # Annotation Source (ENSEMBL) ---------------------------------------------
#
# TxDb <- GenomicFeatures::makeTxDbFromGFF(
#   file = '~/test/Ensembl_GRCh37/Homo_sapiens.GRCh37.87_withChr.gtf.gz',
#   dataSource = 'GENCODE (ENSEMBL GRCh37)',
#   organism = 'Homo sapiens', taxonomyId = 9606
# )
#
# # Import the genome-sequences (GRCh37 from GATK).
# genomeSeqs <- Biostrings::readDNAStringSet(filepath = '/mnt/data/ccbc_environment/general/genomes/hsapiens/hg19_HMF/Homo_sapiens.GRCh37.GATK.illumina.fasta', format = 'fasta')
#
# # Clean the chromosomal names and use the chr-prefix.
# names(genomeSeqs) <- paste0('chr', names(genomeSeqs))
#
# # Generate the ProteoDiscography.
# ProteoDiscography <- ProteoDisco::generateProteoDiscography(
#   TxDb = TxDb,
#   genomeSeqs = genomeSeqs,
#   geneticCode = 'Standard'
# )
#
# ProteoDiscography <- ProteoDisco::importGenomicVariants(
#   ProteoDiscography = ProteoDiscography,
#   # Provide the VCF / MAF files.
#   files = '~/test/post_CDS_cleanse_colon.vcf',
#   # We can replace the original samples within the VCF with nicer names.
#   samplenames = c('Colon missing'),
#   # Number of threads used for parallelization.
#   # We run samples sequentially and parallelize within (variant-wise multi-threading).
#   threads = 10,
#   # For illustration purposes, do not check the validity of the reference anchor.
#   performAnchorCheck = FALSE
# )
#
# ProteoDiscography <- ProteoDisco::incorporateGenomicVariants(
#   ProteoDiscography = ProteoDiscography,
#   # Do not aggregate samples and generate mutant transcripts from the mutations per sample.
#   aggregateSamples = FALSE,
#   # If there are multiple mutations within the same exon (CDS), place them on the same mutant CDS sequence.
#   aggregateWithinExon = TRUE,
#   # Aggregate multiple mutant exons (CDS) within the same transcripts instead of incorporating one at a time.
#   aggregateWithinTranscript = TRUE,
#   # If there are overlapping mutations on the same coding position, retain only the first of the overlapping mutations.
#   # If set to FALSE, throw an error and specify which CDS had overlapping mutations.
#   ignoreOverlappingMutations = TRUE,
#   # Number of threads.
#   threads = 10
# )
#
#
# # Wrappers ----------------------------------------------------------------
#
# # Wrapper for customProDB (derived from their easyRun() method)
# runCustomProDB <- function(pathVCF, pathAnno, sampleName){
#
#   # Load annotations generated by customProDB.
#   load(paste(pathAnno, '/exon_anno.RData', sep = ''))
#   load(paste(pathAnno, "/proteinseq.RData", sep = ""))
#   load(paste(pathAnno, "/procodingseq.RData", sep = ""))
#   load(paste(pathAnno, "/ids.RData", sep = ""))
#
#   # Import VCF (use standardized import).
#   inputVCF <- VariantAnnotation::readVcfAsVRanges(pathVCF, genome = 'hg19')
#   GenomeInfoDb::seqlevelsStyle(inputVCF) <- 'ENSEMBL'
#   inputVCF$REF <- VariantAnnotation::ref(inputVCF)
#   inputVCF$ALT <- VariantAnnotation::alt(inputVCF)
#
#   # Split SNV from InDels (I suppose we treat MNV as InDels).
#   muts.SNV <- inputVCF[VariantAnnotation::isSNV(inputVCF),]
#   muts.InDel <- inputVCF[!VariantAnnotation::isSNV(inputVCF),]
#
#   # Determine which mutations overlap with CDS and on what position.
#   posTable.SNV <- customProDB::Positionincoding(muts.SNV, exon)
#   posTable.InDel <- customProDB::Positionincoding(muts.InDel, exon)
#
#   # Clean names / mutations.
#   getInfo <- function(x) {
#     if(length(unlist(strsplit(x[[4]], ','))) != 0) {
#       return(data.frame(
#         ENSP = gsub('_.*', '', trimws(unique(x[[1]]))),
#         ENST = trimws(unique(x[[2]])),
#         ENSG = trimws(unique(x[[3]])),
#         HGVS.p = gsub('.*_|.*:', '', trimws(unique(x[[1]]))),
#         id = gsub(';.*', '', gsub('.*_', '', x[[1]])),
#         SYMBOL = trimws(unique(unlist(strsplit(x[[4]], ',')))[[1]])
#       ))
#     } else {
#       return(data.frame(
#         ENSP = gsub('_.*', '', trimws(unique(x[[1]]))),
#         ENST = trimws(unique(x[[2]])),
#         ENSG = trimws(unique(x[[3]])),
#         HGVS.p = gsub('.*_|.*:', '', trimws(unique(x[[1]]))),
#         id = gsub(';.*', '', gsub('.*_', '', x[[1]])),
#         SYMBOL = "Unknown"
#       ))
#     }
#   }
#
#   if(length(posTable.InDel) != 0) {
#     # InDels - Generate aberrant mutant-sequences (directly to file...).
#     customProDB::Outputaberrant(
#       positiontab = posTable.InDel,
#       coding = procodingseq %>% dplyr::filter(tx_id %in% unique(posTable.InDel$txid)),
#       proteinseq = proteinseq %>% dplyr::filter(tx_name %in% unique(posTable.InDel$txname)),
#       outfile = sprintf('%s%s_customProDB_InDels.fa', pathAnno, sampleName),
#       ids = ids %>% dplyr::filter(gene_name %in% posTable.InDel$genename)
#     )
#     results.InDel <- Biostrings::readAAStringSet(paste0(pathAnno, sampleName, '_customProDB_InDels.fa'))
#     info.Indel <- do.call(rbind, lapply(strsplit(base::names(results.InDel), '\\|'), getInfo))
#     results.InDel <- tibble::as_tibble(cbind(data.frame(mutantSeq = results.InDel), info.Indel))
#     results.InDel$Type <- 'InDel'
#   }
#
#   if(length(posTable.SNV) != 0) {
#     # Add the genomic position as 'rsID' to trick customProDB in adding it to the header.
#     posTable.SNV$rsid <- sprintf('%s:%s:%s>%s;', posTable.SNV$chr, posTable.SNV$pos, posTable.SNV$refbase, posTable.SNV$varbase)
#
#     # SNV - Generate aberrant mutant-sequences (directly to file...).
#     customProDB::OutputVarproseq(
#       vartable = customProDB::aaVariation(posTable.SNV, procodingseq %>% dplyr::filter(tx_id %in% unique(posTable.SNV$txid))),
#       proteinseq = proteinseq %>% dplyr::filter(tx_name %in% unique(posTable.SNV$txname)),
#       outfile = sprintf('%s%s_customProDB_SNV.fa', pathAnno, sampleName),
#       ids = ids %>% dplyr::filter(gene_name %in% posTable.SNV$genename), lablersid = TRUE
#     )
#
#     # Import outputted mutant sequences.
#     results.SNV <- Biostrings::readAAStringSet(paste0(pathAnno, sampleName, '_customProDB_SNV.fa'))
#     info.SNV <- do.call(rbind, lapply(strsplit(base::names(results.SNV), '\\|'), getInfo))
#     # Convert to tibble and add the incorporated mutation / gene-info.
#     results.SNV <- tibble::as_tibble(cbind(data.frame(mutantSeq = results.SNV), info.SNV))
#     results.SNV$Type <- 'SNV'
#   }
#
#   if(!exists("results.SNV")) results.SNV <- NULL
#   if(!exists("results.InDel")) results.InDel <- NULL
#
#   results.Combined <- dplyr::bind_rows(results.SNV, results.InDel)
#   return(results.Combined)
# }
#
#
# # Import test data-sets ---------------------------------------------------
#
# # Manually-selected dataset.
# path.Validation <- system.file('extdata', 'validationSet_hg19.vcf', package = 'ProteoDisco')
#
#
# z <- runCustomProDB(
#   pathVCF <- '~/test/post_CDS_cleanse_breast.vcf',
#   pathAnno <- '~/test/ProteoDisco/',
#   sampleName = 'CPTAC'
# )
#
# # Run different toolkits --------------------------------------------------
#
# # Initialize list.
# outputResults <- list()
#
# ## ProteoDisco ----
# require(BSgenome.Hsapiens.UCSC.hg19)
# require(TxDb.Hsapiens.UCSC.hg19.knownGene)
#
# ProteoDiscography.hg19 <- ProteoDisco::generateProteoDiscography(TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene, genomeSeqs = BSgenome.Hsapiens.UCSC.hg19)
# files.muts <- system.file('extdata', 'validationSet_hg19.vcf', package = 'ProteoDisco')
# ProteoDiscography.hg19 <- ProteoDisco::importGenomicVariants(ProteoDiscography.hg19, files.muts, ignoreNonMatch = TRUE, threads = 1)
# testSetProteins_hg19 <- readr::read_csv(file = system.file("extdata", "Table1_testSetProteins.csv", package = "ProteoDisco"))
# ProteoDiscography.hg19 <- ProteoDisco::incorporateGenomicVariants(ProteoDiscography = ProteoDiscography.hg19, aggregateSamples = FALSE, aggregateWithinExon = FALSE, aggregateWithinTranscript = TRUE, ignoreOverlappingMutations = TRUE, threads = 2)
# all(testSetProteins_hg19[testSetProteins_hg19$Build %in% "hg19", ]$`Mutant Protein` %in% ProteoDiscography.hg19@mutantTranscripts.genomicVariants$AA.SequenceMut)
#
# ## CustomProDB ----
#
# ### Generate the annotation databases ----
#
# # Retrieve annotations from ENSEMBL.
# # ensembl <- biomaRt::useMart('ENSEMBL_MART_ENSEMBL', dataset='hsapiens_gene_ensembl', host='grch37.ensembl.org')
# # customProDB::PrepareAnnotationEnsembl(mart = ensembl,  annotation_path = '~/test/customProDB/',  splice_matrix = FALSE, dbsnp = NULL, COSMIC = FALSE)
#
# ### Get results of customProDB ----
#
# outputResults$customProDb <- runCustomProDB(
#   pathVCF <- path.Validation,
#   pathAnno <- '~/userData/test/ProteoDisco/',
#   sampleName = 'CPTAC'
# )
#
# testSetProteins_hg19 <- readr::read_csv(file = system.file("extdata", "Table1_testSetProteins.csv",
#                                                            package = "ProteoDisco"))
#
# #18 found, 8 different
# table(testSetProteins_hg19[testSetProteins_hg19$Build %in% "hg19", ]$`Mutant Protein` %in% outputResults$customProDb$mutantSeq)
#
# ## pyQUILTS ----
#
# # from selenium import webdriver
# # from webdriver_manager.chrome import ChromeDriverManager
# # from selenium.webdriver.support.ui import WebDriverWait
# # import glob
# # import os
# # import wget
# #
# #   vcfFileList = glob.glob('*.vcf')
# #   #print(vcfFileList)
# #
# # for x in vcfFileList:
# #   browser = webdriver.Chrome(ChromeDriverManager().install())
# #   browser.get('http://openslice.fenyolab.org/cgi-bin/pyquilts_cgi.pl')
# #   browser.find_element_by_xpath('/html/body/form/input[3]').click();
# #   browser.find_element_by_name("data_file2").send_keys('/path/to/vcffiles/' + x);
# #   browser.find_element_by_name('Submit').click();
# #   #browser.implicitly_wait(1)
# #   browser.find_element_by_link_text("here").click()
# #   autorefreshunit = WebDriverWait(browser, timeout = 120).until(lambda d: d.find_element_by_xpath('/html/body/a[1]'))
# #   assert autorefreshunit.text == "Sample-specific FASTA file"
# #   url = browser.find_element_by_xpath('/html/body/a[1]').get_attribute('href')
# #   filename = wget.download(url, out='/path/to/output/out/')
# #   os.rename(r'/path/to/output/out/variant_proteome.fasta',r'/path/to/output/out/'+x+'.fasta')
# #   browser.quit()
#
# #quilts <- Biostrings::readAAStringSet('~/userData/output/pdisco_comparison/curatedVariantSequences.fasta')
#
# # Combine results ---------------------------------------------------------
#
# vennData <- list(ProteoDisco = which(testSetProteins_hg19[testSetProteins_hg19$Build %in% "hg19", ]$`Mutant Protein` %in% ProteoDiscography.hg19@mutantTranscripts.genomicVariants$AA.SequenceMut),
#                  customProDb = which(testSetProteins_hg19[testSetProteins_hg19$Build %in% "hg19", ]$`Mutant Protein` %in% customProDb$mutantSeq),
#                  QUILTS = which(testSetProteins_hg19[testSetProteins_hg19$Build %in% "hg19", ]$`Mutant Protein` %in% quilts))
#
# svg(filename = "~/userData/output/curatedVariantSequences.venn.svg", height = 10, width = 10)
# ggvenn::ggvenn(vennData, fill_color = c("#0073C2", "#ED4C67", "#F79F1F"),
#                stroke_size = 0.5, set_name_size = 8,
#                text_size = 5) +
#   ggplot2::ggtitle(label = "Curated variant sequences") +
#   ggplot2::theme(plot.title = ggplot2::element_text(face = "bold",
#                                                     size = 21,
#                                                     family = "Helvetica"))
# dev.off()
#
# ## Breast --------------------------------------------------------
#
# sequences <- readr::read_tsv(file = "~/userData/output/CPTAC/CPTAC_Breast.vcf",
#                              skip = 31, col_names = TRUE)
# sequences <- stringr::str_to_upper(gsub(".*SEQ=", "", sequences$CPTAC))
#
# load("~/userData/output/pdisco_comparison/customProDb.Breast.rda")
# customProDb_find_fragments <- sapply(unique(sequences), function(x) any(stringr::str_detect(x, string = customProDb$mutantSeq)))
# table(customProDb_find_fragments)
# load("~/userData/output/pdisco_comparison/proteodisco.breast.rda")
# ProteoDisco_find_fragments <- sapply(unique(sequences), function(x) any(stringr::str_detect(x, string = seq)))
# table(ProteoDisco_find_fragments)
# quilts <- Biostrings::readAAStringSet('~/userData/output/pdisco_comparison/CPTAC_Breast.fasta')
# QUILTS_find_fragments <- sapply(unique(sequences), function(x) any(stringr::str_detect(x, string = quilts)))
# table(QUILTS_find_fragments)
#
# vennData <- list(ProteoDisco = which(ProteoDisco_find_fragments),
#                  customProDb = which(customProDb_find_fragments),
#                  QUILTS = which(QUILTS_find_fragments))
#
# svg(filename = "~/userData/output/CPTAC.Breast.venn.svg", height = 10, width = 10)
# ggvenn::ggvenn(vennData, fill_color = c("#0073C2", "#ED4C67", "#F79F1F"),
#                stroke_size = .5, set_name_size = 8,
#                fill_alpha = .3, stroke_alpha = .8,
#                text_size = 5) +
#   ggplot2::ggtitle(label = "Mertins et al. - CPTAC Breast") +
#   ggplot2::theme(plot.title = ggplot2::element_text(face = "bold",
#                                                     size = 21,
#                                                     family = "Helvetica"))
# dev.off()
#
# ## Colon --------------------------------------------------------
#
# disp <- list.files(path = "~/userData/output/Colon", pattern = ".vcf$", full.names = TRUE)
# sequences <- dplyr::bind_rows(lapply(disp, function(file) {
#   x <- readr::read_tsv(file, skip = 31, col_names = TRUE, col_types = "cdcccccccc")
#   x$sample <- colnames(x)[10]
#   colnames(x)[10] <- "Colon"
#   return(x)
# }))
# sequences <- stringr::str_to_upper(gsub(".*SEQ=", "", sequences$Colon))
#
# load("~/userData/output/pdisco_comparison/customProDb.Colon.rda")
# customProDb <- dplyr::bind_rows(customProDb)
# customProDb_find_fragments <- sapply(unique(sequences), function(x) any(stringr::str_detect(x, string = customProDb$mutantSeq)))
# table(customProDb_find_fragments)
# load("~/userData/output/pdisco_comparison/proteodisco.Colon.rda")
# ProteoDisco_find_fragments <- sapply(unique(sequences), function(x) any(stringr::str_detect(x, string = seq)))
# table(ProteoDisco_find_fragments)
# quilts <- do.call('c', lapply(head(list.files(path = "~/userData/output/pdisco_comparison/",
#                                               pattern = ".fasta", full.names = TRUE), n = 90),
#                               Biostrings::readAAStringSet))
# QUILTS_find_fragments <- sapply(unique(sequences), function(x) any(stringr::str_detect(x, string = quilts)))
# table(QUILTS_find_fragments)
#
# vennData <- list(ProteoDisco = which(ProteoDisco_find_fragments),
#                  customProDb = which(customProDb_find_fragments),
#                  QUILTS = which(QUILTS_find_fragments))
#
# svg(filename = "~/userData/output/CPTAC.Colon.venn.svg", height = 10, width = 10)
# ggvenn::ggvenn(vennData, fill_color = c("#0073C2", "#ED4C67", "#F79F1F"),
#                stroke_size = 0.5, set_name_size = 8,
#                text_size = 5) +
#   ggplot2::ggtitle(label = "Weng et al. - Colon") +
#   ggplot2::theme(plot.title = ggplot2::element_text(face = "bold",
#                                                     size = 21,
#                                                     family = "Helvetica"))
# dev.off()
